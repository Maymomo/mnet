<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>var data = {"files":[{"path":["/","home","maymomo","project","mnet","src","buffer.rs"],"content":"#[derive(Debug)]\npub enum MBufErr {\n    NOMORESIZE,\n    CONSUMEERR,\n    COMMITERR,\n}\n\npub struct MBuf {\n    buf: Vec\u003cu8\u003e,\n    read: usize,\n    write: usize,\n    cap: usize,\n}\n\nimpl MBuf {\n    pub fn new(buf_cap: usize) -\u003e MBuf {\n        MBuf {\n            buf: vec![0; buf_cap],\n            read: 0,\n            write: 0,\n            cap: buf_cap,\n        }\n    }\n\n    pub fn data(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.buf.as_slice()[self.read..self.write]\n    }\n\n    pub fn consume(\u0026mut self, size: usize) -\u003e Result\u003c(), MBufErr\u003e {\n        let new_read = self.read + size;\n        if new_read \u003e self.write {\n            return Err(MBufErr::CONSUMEERR);\n        }\n        self.read = new_read;\n        Ok(())\n    }\n\n    pub fn prepare(\u0026mut self, size: usize) -\u003e Result\u003c\u0026mut [u8], MBufErr\u003e {\n        self.reserve(size)?;\n        Ok(\u0026mut self.buf.as_mut_slice()[self.write..self.write + size])\n    }\n\n    pub fn commit(\u0026mut self, size: usize) -\u003e Result\u003c(), MBufErr\u003e {\n        let new_write = self.write + size;\n        if new_write \u003e self.cap {\n            return Err(MBufErr::COMMITERR);\n        }\n        self.write = new_write;\n        Ok(())\n    }\n\n    fn reserve(\u0026mut self, size: usize) -\u003e Result\u003c(), MBufErr\u003e {\n        if self.cap() - self.write \u003e= size {\n            return Ok(());\n        }\n\n        if self.remain() \u003c size {\n            return Err(MBufErr::NOMORESIZE);\n        }\n\n        unsafe {\n            let ptr = self.buf.as_mut_ptr();\n            std::ptr::copy(ptr.add(self.read), ptr, self.len());\n        }\n\n        let old_len = self.len();\n        self.read = 0;\n        self.write = old_len;\n        Ok(())\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.write - self.read\n    }\n\n    pub fn cap(\u0026self) -\u003e usize {\n        self.cap\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    pub fn remain(\u0026self) -\u003e usize {\n        self.cap() - self.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_buffer() {\n        let mut buffer = MBuf::new(1024);\n        let nread = read_data(buffer.prepare(10).unwrap(), 5, 1);\n        buffer.commit(nread).unwrap();\n        assert_eq!(5, buffer.len());\n        assert_eq!(1024 - 5, buffer.remain());\n        for i in buffer.data() {\n            assert_eq!(1 as u8, *i);\n        }\n        buffer.consume(5).unwrap();\n        assert_eq!(0, buffer.len());\n        assert_eq!(buffer.cap(), buffer.remain());\n        let nread = read_data(buffer.prepare(1024).unwrap(), 1024, 2);\n        buffer.commit(nread).unwrap();\n        assert_eq!(0, buffer.remain());\n        assert_eq!(buffer.cap(), buffer.len());\n        for i in buffer.data() {\n            assert_eq!(2 as u8, *i);\n        }\n\n        match buffer.commit(10000) {\n            Err(_) =\u003e {}\n            _ =\u003e {\n                panic!(\"commit error\");\n            }\n        }\n        match buffer.consume(10000) {\n            Err(_) =\u003e {}\n            _ =\u003e {\n                panic!(\"consume error\");\n            }\n        }\n    }\n\n    fn read_data(buf: \u0026mut [u8], nread: usize, v: u8) -\u003e usize {\n        for i in 0..nread {\n            buf[i as usize] = v;\n        }\n        nread\n    }\n}\n","traces":[{"line":16,"address":4217504,"length":1,"stats":{"Line":1}},{"line":18,"address":4217518,"length":1,"stats":{"Line":1}},{"line":25,"address":4217616,"length":1,"stats":{"Line":1}},{"line":26,"address":4217625,"length":1,"stats":{"Line":1}},{"line":29,"address":4217728,"length":1,"stats":{"Line":1}},{"line":30,"address":4217742,"length":1,"stats":{"Line":1}},{"line":31,"address":4217777,"length":1,"stats":{"Line":1}},{"line":32,"address":4217814,"length":1,"stats":{"Line":1}},{"line":34,"address":4217793,"length":1,"stats":{"Line":1}},{"line":35,"address":4217807,"length":1,"stats":{"Line":1}},{"line":38,"address":4217856,"length":1,"stats":{"Line":1}},{"line":39,"address":4217873,"length":1,"stats":{"Line":1}},{"line":40,"address":4217996,"length":1,"stats":{"Line":1}},{"line":43,"address":4218176,"length":1,"stats":{"Line":1}},{"line":44,"address":4218190,"length":1,"stats":{"Line":1}},{"line":45,"address":4218225,"length":1,"stats":{"Line":1}},{"line":46,"address":4218262,"length":1,"stats":{"Line":1}},{"line":48,"address":4218241,"length":1,"stats":{"Line":1}},{"line":49,"address":4218255,"length":1,"stats":{"Line":1}},{"line":52,"address":4218304,"length":1,"stats":{"Line":1}},{"line":53,"address":4218318,"length":1,"stats":{"Line":1}},{"line":54,"address":4218393,"length":1,"stats":{"Line":1}},{"line":57,"address":4218376,"length":1,"stats":{"Line":1}},{"line":58,"address":4218439,"length":1,"stats":{"Line":0}},{"line":62,"address":4218419,"length":1,"stats":{"Line":1}},{"line":63,"address":4218454,"length":1,"stats":{"Line":1}},{"line":66,"address":4218521,"length":1,"stats":{"Line":1}},{"line":67,"address":4218536,"length":1,"stats":{"Line":1}},{"line":68,"address":4218549,"length":1,"stats":{"Line":1}},{"line":69,"address":4218563,"length":1,"stats":{"Line":1}},{"line":72,"address":4218592,"length":1,"stats":{"Line":1}},{"line":73,"address":4218601,"length":1,"stats":{"Line":1}},{"line":76,"address":4218672,"length":1,"stats":{"Line":1}},{"line":77,"address":4218677,"length":1,"stats":{"Line":1}},{"line":80,"address":4218688,"length":1,"stats":{"Line":0}},{"line":81,"address":4218697,"length":1,"stats":{"Line":0}},{"line":84,"address":4218752,"length":1,"stats":{"Line":1}},{"line":85,"address":4218761,"length":1,"stats":{"Line":1}},{"line":93,"address":4220368,"length":1,"stats":{"Line":2}},{"line":94,"address":4220375,"length":1,"stats":{"Line":1}},{"line":95,"address":4220431,"length":1,"stats":{"Line":1}},{"line":96,"address":4220541,"length":1,"stats":{"Line":1}},{"line":97,"address":4220596,"length":1,"stats":{"Line":1}},{"line":98,"address":4220726,"length":1,"stats":{"Line":1}},{"line":99,"address":4221238,"length":1,"stats":{"Line":1}},{"line":100,"address":4221817,"length":1,"stats":{"Line":1}},{"line":102,"address":4221750,"length":1,"stats":{"Line":1}},{"line":103,"address":4222279,"length":1,"stats":{"Line":1}},{"line":104,"address":4222417,"length":1,"stats":{"Line":1}},{"line":105,"address":4222949,"length":1,"stats":{"Line":1}},{"line":106,"address":4223385,"length":1,"stats":{"Line":1}},{"line":107,"address":4223440,"length":1,"stats":{"Line":1}},{"line":108,"address":4223578,"length":1,"stats":{"Line":1}},{"line":109,"address":4224097,"length":1,"stats":{"Line":1}},{"line":110,"address":4224631,"length":1,"stats":{"Line":1}},{"line":113,"address":4224567,"length":1,"stats":{"Line":1}},{"line":114,"address":4225047,"length":1,"stats":{"Line":1}},{"line":116,"address":4225078,"length":1,"stats":{"Line":0}},{"line":119,"address":4225120,"length":1,"stats":{"Line":1}},{"line":120,"address":4225146,"length":1,"stats":{"Line":1}},{"line":122,"address":4225177,"length":1,"stats":{"Line":0}},{"line":127,"address":4220080,"length":1,"stats":{"Line":1}},{"line":128,"address":4220106,"length":1,"stats":{"Line":1}},{"line":129,"address":4220264,"length":1,"stats":{"Line":1}},{"line":131,"address":4220207,"length":1,"stats":{"Line":1}}],"covered":60,"coverable":65},{"path":["/","home","maymomo","project","mnet","src","lib.rs"],"content":"pub mod buffer;\npub mod client;\npub mod mqueue;\npub mod server;\n\nfn mnet_init() {}\n","traces":[{"line":6,"address":4211792,"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1}]};</script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : '')
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + (file.covered / file.coverable * 100).toFixed(2) + '%)' : '')
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const files = data.files.map(file => ({...file, path: file.path.slice(commonPath.length), parent: commonPath}));
  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
  };

  ReactDOM.render(e(App, {root}), document.getElementById('root'));
}());
</script>
</body>
</html>